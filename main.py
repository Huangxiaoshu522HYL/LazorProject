import osimport timefrom PIL import Image, ImageDrawfrom copy import deepcopyclass Lazer():    """    Create a Lazer Class for Building lazer object inside the board game\    """    def __init__(self, pos:tuple, dir: tuple):        """        Initial Allocation for Lazer Object                *parameter*        pos <tuple>: a tuple location (x,y) coordinator represents lazer position                dir <tuple>: a tuple (x,y) represents the directions of lazer in the next round                *var*        next <Lazer>: the next lazer (for normal circumstances without refrack)         stored inside. Used in the later part for get_next() function in Board class.                 reflectnext <Lazer>: the second next lazer generated seperately with "next <Lazer>".         especially for Refrack Case                """        self.pos = pos        self.dir = dir        self.next = None        self.reflectnext = None    def __eq__(self,other):        """        compare the current lazer with other lazer by positions, direction, and data type                *parameter*                other <Lazer>: the lazer used to compare with current lazer                *Output*:        return boolean for True if two lazers are equal, and false otherwise.         """        return isinstance(other,Lazer)and self.pos == other.pos and self.dir == other.dir        def __hash__(self):        """        Generate a hash value for every unique Lazer object.         This is used to make Lazer object Hashable in the later part                *Output*        Return a int for hashkey        """        return hash((self.pos, self.dir))class Block():    """    Create Block Object for represents the block inside board game    """    def __init__(self,pos:tuple, type:str):        """        Initialize the block object.                *parameter*        pos <Tuple>: Location of that block object in <x,y>        type <str>: Block type of this block object.                Type of block would be:            x = no block allowed             o = blocks allowed            A = fixed reflect block             B = fixed opaque block             C = fixed refract block        """        self.pos = pos        self.type = type    def lazer_output(self,inputLazer):        """        Function used to generate output lazer after one input lazer crossing that block                *parameter*        inputLazer <Lazer>: is the input Lazer of that box.        *Output*:        return the Lazer output from this block            *Var*:            OutputLazer <List[Lazer]>: Stored the output lazer from that block                    """        outputlazer = []                """        (1)Case if block is in "noblock" "blocks allowed" or "Fixed Refract Block"        Then just one outputlazer exists        (2) Case if block is in "Fixed Reflact Block" or "Fixed Refract block"        Then Location unchanged, but direction of that input lazer will be adjusted after         Function procced        (3) Case if block is in "Fixed Opaque block", Then no output lazer exists.        """        if self.type in ['x','o','C']:            out_posx = inputLazer.pos[0]+inputLazer.dir[0]            out_posy = inputLazer.pos[1]+inputLazer.dir[1]            out_dir = inputLazer.dir            out_pos = (out_posx,out_posy)            outputlazer.append(Lazer(out_pos,out_dir))        if self.type in ['A','C']:            out_pos = inputLazer.pos            if inputLazer.pos[0] -1 == self.pos[0]:                out_dir = (inputLazer.dir[0],-inputLazer.dir[1])            else:                out_dir = (-inputLazer.dir[0],inputLazer.dir[1])            """            Append the outputlazer list after generating all outputlazer from prefious nested-if statement.             """            outputlazer.append(Lazer(out_pos,out_dir))        return outputlazerclass Board():    """    Board class represents the whole board of this game    """    def __init__(self,start:list[Lazer],data:list[list],target:list[list]):        """        Initialize of Board Class        *Parameter*        start <List[Lazer]>: List of start lazer object for this board game setting,         stored its position, direction        and its linked nodes for its next lazer object        data <list[list]>: the 2D List represents the current status         on board position for every columns and rows        target <list[list]>: The list of all target positions                *var*:        width, height <int>: Board width and height is linked with data stored in board object                grid <list>: Board grid represents the grid rows and columns data.         Each Row stored with Block Object, and its current status stored in data list.                 pointpassed <set>: The set to store point passed in previous lazers        lazerprocessed <set>: The set to store lazers that have been processed in previous process                    """        self.data = data        self.width = len(data[0])        self.height = len(data)        self.target = target        self.start = start        self.grid = []        self.pointpassed = set()        self.lazerprocessed = set()        """        Using for loop to generate the grid status         """        for h in range(self.height):            row = []            for w in range(self.width):                row.append(Block((2*w,2*h),data[h][w]))            self.grid.append(row)           """        build up the lazers inside this board.        """        self.buildlazer()    def buildlazer(self):        """        Function used to startup the building lazer process        We will use recurssion to recall function "build_A_lazer"        while looping from lazers to its processor        """        for lazer in self.start:            self.build_A_lazer(lazer)    def build_A_lazer(self,lazer:Lazer):        """        The recurssion function to generate lazer from the very first startup lazers,        to the end by recurssive process for linked node lazers one by one.                 *parameter*        lazer <Lazer>: the input lazer for the starting process of building lazers.        """        if lazer in self.lazerprocessed:            """            If this lazer has been processed and stored inside the lazerprocessed set            we return and do nothing            """            return                """        Stored the lazer and point it passed        """        self.lazerprocessed.add(lazer)        self.pointpassed.add(lazer.pos)                """        Check whether this lazer is valid or not after this iteration.         If not a valid lazer, we return.         """        if self.not_valid_lazer(lazer):            return        """        If it is a valid lazer, check its processor lazers.         """        next_lazer_list = self.get_next(lazer)        """        If this lazer facing reflect or refract block, then it may contains 2 processors lazers        We append its processor by cases, and doing recurssion based on all its processors        """        if len(next_lazer_list) == 1:            lazer.next = next_lazer_list[0]            self.build_A_lazer(lazer.next)        elif len(next_lazer_list) == 2:            lazer.next, lazer.reflectnext = next_lazer_list            self.build_A_lazer(lazer.next)            self.build_A_lazer(lazer.reflectnext)                def not_valid_lazer(self,lazer):        """        Function used to check whether this lazer is a valid lazer        That is, lazer's processor possible locations are appropriately located inside the board.                 *Parameter*        lazer <Lazer>: the lazer inputted to check its validation.        *Output*        boolean for True if its all possible processor locations are appropriate,         and false otherwise        """                next_x = lazer.pos[0] + lazer.dir[0]        next_y = lazer.pos[1] + lazer.dir[1]        if 0 <= next_x <= 2 * self.width and 0 <= next_y <= 2 * self.height:            return False        else:            return True           def get_next(self,lazer)->list[Lazer]:        """        Function used to check its lazer crossing which block and creating what lazers         after crossing that box.                 *parameter*        lazer <Lazer>:the lazer inputted to check its processor after interaction        *var*        x,y <int>: lazer position        dir_x,dir_y <int>: lazer direction faced        enter_block <Block>: The interacted block that lazer crossed        *Output*        next_lazer_list <list[Lazer]> The list of lazer output recalled by the lazer_output()        """        dir_x, dir_y = lazer.dir        x, y = lazer.pos        """        Check the location x-axis, if it's odd, then we need         to adjust the y-axis for block locations and vice versa.         """        if x % 2 == 1:            enter_block = self.grid[int((y+dir_y-1)/2)][int((x-1)/2)]        else:            enter_block = self.grid[int((y-1)/2)][int((x+dir_x-1)/2)]        next_lazer_list = enter_block.lazer_output(lazer)        return next_lazer_list    def save_pic(self,filename):        """        Function used to save the output picture once there's a valid solution                *Parameter*        filename <str>: Preferred output solution picture file name.                 *var*        colordict <dictionary>: stored the color map for corresponding block type        block_size <int>: default block size inside the picture        """        colordic = {"o": (80, 80, 80), "x": (125, 125, 125), "A": (255, 255, 255),                      "B": (37, 35, 36), "C": (210, 210, 210)}                block_size = 100                image = Image.new('RGB', (self.width * block_size,                          self.height * block_size), 'white')                draw = ImageDraw.Draw(image)        def draw_legend():            """            Function used to generate legend for each solutions graph.             This will output a legend box in the left down corner of picture.             *var*            legend_x,legend_y <int>: Startup location of legend box            spacing <int>: spacing of new lines.            """            legend_x = 10            legend_y = self.height * block_size - 120            spacing = 15            # Drawing block type legend            draw.text((legend_x, legend_y), "Legend:", fill=(255, 0, 0))            legend_y += spacing            """            For each block_type read, create text and block preview generated in legend box.             """            for block_type, color in colordic.items():                draw.rectangle([legend_x, legend_y, legend_x + 8, legend_y + 8], fill=color, outline=(0, 0, 0))                if block_type == "x":                    draw.text((legend_x + 15, legend_y), "No block", fill=(255, 0, 0))                elif block_type == "o":                    draw.text((legend_x + 15, legend_y), "Block Allowed", fill=(255, 0, 0))                elif block_type == "A":                    draw.text((legend_x + 15, legend_y), "Reflect Block", fill=(255, 0, 0))                elif block_type=="B":                    draw.text((legend_x + 15, legend_y), "Opaque block", fill=(255, 0, 0))                elif block_type == "C":                    draw.text((legend_x + 15, legend_y), "Refrack block", fill=(255, 0, 0))                legend_y += spacing            """             Generate Legend for Point Target and Lazer Object            """            draw.ellipse([legend_x, legend_y, legend_x + 10, legend_y + 10], fill=(220, 20, 60), outline=(0, 0, 0))            draw.text((legend_x + 15, legend_y), "Point Target", fill=(255, 0, 0))            legend_y += spacing            draw.line([legend_x, legend_y + 5, legend_x + 10, legend_y + 5], fill=(220, 20, 60), width=2)            draw.text((legend_x + 15, legend_y), "Laser Path", fill=(255, 0, 0))        def draw_lazer_line(lazer: Lazer, last_pos: tuple):            """            Function used for draw the lazer on solution graph.             We use recurssion to draw start up lazer and its process            by recalling this function similarly as build_Lazer function                        *parameter*            last_pos <tuple>: the last position inputted for lazer line.             lazer <Lazer>: the lazer inputted to be draw.                         """            if not isinstance(lazer,Lazer):                return            """            Re-adjust the position of lazer            """            x, y = [pos * block_size / 2 for pos in lazer.pos]            cur_pos = (x, y)            """            Draw the current lazer, and find its processor and draw by recall itself            """            draw.line((last_pos, cur_pos), fill=(220, 20, 60), width=2)            draw_lazer_line(lazer.next, cur_pos)            draw_lazer_line(lazer.reflectnext, cur_pos)        """        Draw the block object        """        for y in range(self.height):            for x in range(self.width):                draw.rectangle((x * block_size, y * block_size, (x+1) * block_size, (y + 1) * block_size),                               fill=colordic[self.data[y][x]], outline=(0, 0, 0))        """        Draw lazer by startup the start lazer        """        for start_lazer in self.start:            x, y = [pos * block_size / 2 for pos in start_lazer.pos]            draw.ellipse((x - 5, y - 5, x + 5, y + 5), fill=(220,                         20, 60), outline=(255, 255, 255), width=1)            draw_lazer_line(start_lazer.next, (x, y))            draw_lazer_line(start_lazer.reflectnext, (x, y))        """        Draw target points        """        for target in self.target:            x, y = [pos * block_size / 2 for pos in target]            draw.ellipse((x - 10, y - 10, x + 10, y + 10),                         fill=(220, 20, 60), outline=(255, 255, 255), width=1)        """        Draw the legend        """        draw_legend()        """        Save the image inside the result folder.         Notice that result folder should be prepared before this program runs.         """        image.save("./result/%s.png" % filename)class Game():    """    Game class use to mainly store this game stats    """    def __init__(self, name):        """        Initialization of Game class. Stored all data including        gamename, game grid, blocks, lazers targets attributes.         *parameter*        name <str>: the name of this game setup. Linked to inputted bff board        file name.        """        self.name = name.split(".")[0]        (self.grid, self.blocks, self.lazers,            self.targets) = self.read_bff(filename)        self.width = len(self.grid[0])        self.height = len(self.grid)    def read_bff(self,name):        """        Function used to read the board file and convert all its data        for setup parameters.        *parameter*        name <str>: The board file name inputted for filestream reading        """        with open("./bff_files/%s"%name) as f:            """            stored the 2D-grid list <list[list]>, block <dict>. Lazer <list[list]>            target<list[tuple]> after function recalled.             """            grid = []            block = {}            lazer = []            target = []            """            Grid_checker used to check whether file line_streamer is still reading             parts in Grid data in board file.             """            grid_checker = False            for line in f.readlines():                if line.startswith("GRID START"):                    grid_checker = True                    continue                elif line.startswith("GRID STOP"):                    grid_checker = False                    continue                elif grid_checker:                    grid.append(list(line.strip().replace(" ", "")))                elif line[0] in ["A","B","C"]:                    try:                        block[line[0]] = int("".join(line.replace(" ", "")[1:]))                    except:                        raise ValueError("Double Check your Block Parameters inside BFF file")                elif line[0]== "L":                    try:                        x, y, vx, vy = [int(s) for s in line.split(" ")[1:]]                    except:                        raise ValueError("Double Check your Lazer Parameters inside BFF file")                    lazer.append(((x,y),(vx,vy)))                elif line[0] == "P":                    try:                        x, y = [int(s) for s in line.split(" ")[1:]]                    except:                        raise ValueError("Double Check your Target Points Parameters inside BFF file")                    target.append((x,y))        return grid,block,lazer,target    def get_board_permutations(self) -> list[list]:        """        Function for finding all permutations of board based on  its initial setup.         *output*        Return the permutations <list[list]> for storing all possible combinations of this game board.         """        def backtrack(current, original, check):            """            backtrack function try for finding out all possible permutations by Depth First Search.             Find the deepst lazer and backtrack to the intersection                        *parameter*            current <list>: the initial normally empty list for storing             now-locations permutation and prepared for later permutation            original <list>: The original permutation that needed to be searched            check <list[bool binary]>: equal to 1 or 0 to check whether that permutation has been checked            in searching process            """            if len(current) == len(original):                """                 If the current length equal to original length of permutaiton                end the search, all permutations finished searching                """                permutations.append(current)                return            for i in range(len(original)):                """                check the permuation one by one throughout list                """                if check[i] == 1:                    """                    if already check, skip to next permuation                    """                    continue                if i > 0 and original[i] == original[i-1] and check[i-1] == 0:                    """                    If duplicated items exist, though not checked, skip to next permutation                    """                    continue                """                Reset this permutation to be checked. And conduct DFS for backtrak again by recalling function itself.                 """                check[i] = 1                backtrack(current+[original[i]], original, check)                """                Reset this permutation to be unchecked after this permutation backtrack completed.                To find other possibilities of permutations.                 """                check[i] = 0        """        Initialize permutations list, and counted blocktype with "O" type, that         all possible block permutations could be tracked. This all "O" block type        Combinations should be linked to origin list.        """        permutations = []        o_num = sum([line.count("o") for line in self.grid]) - \sum(self.blocks.values())        original = ["o"] * o_num + \            list("".join([k*v for k, v in self.blocks.items()]))        check = [0 for _ in range(len(original))]        backtrack([], original, check)        return permutations            def solve(self):        """        Function used to solve out the game. First getting all possible permutations of block arrangement        """        permutations = self.get_board_permutations()        """        Iterate all permuataions one by one and check whether it solve out the game.         """        for iter in permutations:            """            For each permutation, make a new deepcopy of grid data to prevent shallow copy changing original data.            """            data = deepcopy(self.grid)            i = 0            for y in range(self.height):                for x in range(self.width):                    """                    If finding a possible self-made block point "o", record this and count i+1.                     """                    if data[y][x] == "o":                        data[y][x] = iter[i]                        i += 1                    else:                        continue            start= []            """            Read the startup lazer            """            for lazer in self.lazers:                start.append(Lazer(lazer[0], lazer[1]))            """            Read the startup board data            """            gameboard = Board(start,data, self.targets)            """            Final check of the game is solved or not. If all memory of point passed             are passed by lazers, then solve and recall the save_pic function to output the solutions.             """            if all([target in gameboard.pointpassed for target in self.targets]):                gameboard.save_pic(self.name)                print("Solution Found!")                return        print("No Solution.")            if __name__ == "__main__":    for filename in os.listdir("./bff_files"):           #filename = "yarn_5.bff"        print("Start solving for %s ..." % (filename))        t1 = time.time()        game = Game(filename)        game.solve()        t2 = time.time()        print("Run time: %.2f seconds" % (t2 - t1))